"Information Item ID","realization Of","Name","Description (characteristics)","Source information item","Source definition","publications","resources"
"INF_NeOn_1","INF1","Ontology purpose","","NeOn541","","",""
"INF_NeOn_2","INF2","Ontology scope","","NeOn541","","",""
"INF_NeOn_3","INF3","Ontology level of formality","","NeOn541","","",""
"INF_NeOn_4","INF4","Ontology list with intended users","","NeOn541","","",""
"INF_NeOn_5","INF5","Ontology use-cases","","NeOn541","","",""
"INF_NeOn_6","INF6","Ontology CQs (natural language) NeOn","","NeOn541","","",""
"INF_NeOn_7","INF7","Ontology CQs answers (natural language)","","NeOn541","","",""
"INF_NeOn_8","INF8","Ontology Groups of CQs","","NeOn541","","",""
"INF_NeOn_9","INF9","Ontology CQs validity confirmation","","NeOn541","","",""
"INF_NeOn_10","INF10","Ontology CQs priorities","","NeOn541","","",""
"INF_NeOn_11","INF11","Ontology CQs validity criteria"," Correctness. Inspired on [1, 2], we can say that a set of requirements is correct if each requirement refers to some features of the ontology to be developed. That is, any requirement is necessary.   Completeness. In [3], a requirement specification is considered as complete if no requirement is omitted. Practically and adapting this consideration to the ontology engineering field, we can say that if users and domain experts review the requirements and confirm that they do not know more necessary requirements, then the set of requirements can be considered complete.   Consistent. The set of requirements can be considered internally consistent if no conflicts exit between requirements. Conflicts can be between terms (different terminology is used in the requirements to refer to the same need) and between characteristics (two or more requirements refer to contradictory features of the ontology to be developed).  Verificable. Based on [2, 1], we can say that the set of requirements is verificable if each requirement is verificable. That is, a finite process with a reasonable cost exists to test that the final ontology satisfies each requirement. A necessary condition to have a verificable requirement is that such a requirement should be unambiguous.   Understandable. Each requirement must be understandable by users and domain experts. No Ambiguity. Based on [2, 1], we can say that an ontology requirement is unambiguous if it has only one interpretation.  Conciseness. Each and every requirement is relevant, and there are no duplicated or irrelevant requirements.  Realism. Requirement meanings must make sense in the domain.  Modifiable. Based on [2, 1], we can say that a set of requirements is modifiable if its structure and style allow to change issues in an easy, complete and consistent way.  Traceable. Based on [2, 1], we can say that an ontology requirement is retraceable if its origin is known and it can be referred to in other documents during the ontology development. A necessary condition to have retraceable requirements is that such requirements should be referred in a unique way (normally using a kind of code).  -- [1] IEEE Recommended Practice for Software Requirements Specifications. IEEE St 830-1993 [2] A. Davis. Software Requirements: Objects, Functions and States, Upper Saddle River, New Jersey: Prentice Hall, 1993. [3] B.J. Wielinga, A.T. Schreiber, J.A.C. Sandberg. From Thesaurus to Ontology. First International Conference of Knowledge Capture KCAP01 Victoria, British Columbia, Canada, ACM Press 2001. ","NeOn541","NeOn D5.4.1","Pub29, Pub30, Pub31",""
"INF_NeOn_12","INF12","Ontology Pre-glossary","","NeOn541","","",""
"INF_NeOn_13","INF13","Ontological needs","Non-further defined needs used to create ontology requirements.","NeOn541","Sven.Lieber@ugent.be","",""
"INF_NeOn_14","INF14","Ontology Requirements Specifications Document (ORSD) NeOn","","NeOn541","","",""
"INF_NeOn_15","INF15","Set of relevant non-ontological resources","","NeOn541","","",""
"INF_NeOn_16","INF16","Non-ontological resource reuse candidates","","NeOn541","","",""
"INF_NeOn_17","INF17","Non-ontological resource lexical entries","","NeOn541","","",""
"INF_NeOn_18","INF18","Non-ontological resource precision","","NeOn541","","",""
"INF_NeOn_19","INF19","Non-ontological resource coverage","","NeOn541","","",""
"INF_NeOn_20","INF20","Non-ontological resource consensus","","NeOn541","","",""
"INF_NeOn_21","INF21","Non-ontological resource assessment table","","NeOn541","","",""
"INF_NeON_22","INF22","Non-ontological resource quality criteria","","NeOn542","","",""
"INF_NeOn_23","INF23","Ontology (implemented)","","NeOn541","","",""
"INF_NeOn_24","INF24","Non-ontological resource documentation","","NeOn541","","",""
"INF_NeOn_25","INF25","Non-ontological resource schema","","NeOn541","","",""
"INF_NeOn_26","INF26","Non-ontological resource data model","","NeOn541","","",""
"INF_NeOn_27","INF27","Non-ontological reengineering pattern","","NeOn541","","",""
"INF_NeOn_28","INF28","Conceptual model","","NeOn541","","",""
"INF_NeOn_29","INF29","Ontology Requirements addressed by Ontology Design Patterns (candidates)","","NeOn542","","",""
"INF_NeOn_30","INF30","Identified Ontology Design Pattern Types","","NeOn542","","",""
"INF_UPON_1","INF31","Domain Experts interview outcome","","UPON","","",""
"INF_UPON_2","INF32","Application specific documents","","UPON","","",""
"INF_UPON_3","INF33","Application Lexicon","A lexicon is defined as the set of terms L = {t_i}, being i elementOf N and i <= i_max, where i_max = |L| An application Lexicon, AL, is a lexicon where the terms pertain to a given application APP, as stated by a community of application experts AL = {at_i elementOf L |pertains(at_i, APP)|, being i elementOf N","UPON","","",""
"INF_UPON_4","INF6","Ontology CQs (natural language) UPON","","UPON","","",""
"INF_UPON_5","INF5","Ontology use-cases UPON","","UPON","","",""
"INF_UPON_6","INF34","Ontology Domain UPON","","UPON","","",""
"INF_UPON_7","INF2","Ontology Scope UPON","","UPON","","",""
"INF_UPON_8","INF1","Ontology Purpose UPON","","UPON","","",""
"INF_UPON_9","INF4","Ontology Intended users UPON","","UPON","","",""
"INF_UPON_10","INF35","Storyboard","A panel or series of panels of rough sketches outlining the sequence of the activities that take place in a particular scenario.","UPON","","",""
"INF_UPON_11","INF10","Ontology Use-cases Priorities UPON","","","","",""
"INF_UPON_12","INF36","Domain Lexicon","The domain lexicon is a lexicon validated by a community of domain experts. DL = {dt_i elemtnOf L|pertains(dt_i, Dom)}, being i elementOf N, where Dom is the domain of interest.","UPON","","",""
"INF_UPON_13","INF37","Reference Lexicon","The reference lexicon is a lexicon validated by a community of application and domaine xperts with the coordination of knowledge engieners. RL = (AL intersection DL) union deltaAL union deltaDL, where  deltaAL = {t_i elementOf AL\DL|approved(t_i)}, being i elementOf N, and deltaDL = {t_i elementOf DL\AL|approved(t_i)}, being i elementOf N","UPON","","",""
"INF_UPON_14","INF38","Reference Glossary","A glossary G is defined as the finite set of terms belonging to a lexicon L paired with the corresponding descriptions validated by the reference community. The couple term and description is defined as the glossary entry gi. The reference glossary, RG, is a glossary validated by a community of application and domain experts with the coordination of knowledge engineers. G = {<t_i, des_i> | t_i elementOf L caret des_i elementOf DES caret validated(t_i, des_i)},  g_i = <t_i, des_i>, being i elementOf N RG subset RL x DES RL = {rt_i}, being i elementOf N DES = {des_i}, being i elementOf N, where des_i is the textual description of term t_i","UPON","","",""
"INF_UPON_15","INF53","Ontological Resource reuse candidates","","UPON","","",""
"INF_UPON_16","INF16","Non-ontological resource reuse candidates","","UPON","","",""
"INF_UPON_17","INF54","UML class diagrams","","UPON","","",""
"INF_UPON_18","INF55","UML activity diagrams","","UPON","","",""
"INF_UPON_19","INF56","Semantic Network","Given a finite set C of concepts and a finite set R of relationships established among concepts, a SN is defined as SN = (C,R) C = {c_i}, being i elementOf N R = IsA union De union DR = { <c_i, c_k> } subset C x C and i,k elementOf N where isA = { < c_i, c_k > | gen(c_i, c_k)}, De = { < c_i, c_k > | partOf(c_i, c_k)}, DR = { < c_i, c_k > | rel(c_i, c_k)}. where gen, partOf, and rel are, respectively, the generalization, the aggregation, and the association relationships","UPON","","",""
"INF_UPON_20","INF23","Ontology (implemented) UPON","","UPON","","",""
"INF_UPON_21","INF57","Ontology (tested)","","UPON","","",""
"INF_SAMOD_1","INF35","Motivating scenarios (MS) SAMOD","A motivating scenario [1] is a small story problem that provides a short description and a set of informal and intuitive examples to the problem it talks about. Usually, it implicitly bring with it an informal and intended semantics hidden behind natural language descriptions. In our methodology, a motivation scenario is composed by: – a name that characterises it; – a natural language description that presents a problem to address; – one or more examples according to the description. MS = (name; description; one or more examples) -- [1] M. Uschold, M. Gruninger, Ontologies: principles, methods and applications, Knowl. Eng. Rev. 11 (2) (1996).","SAMOD","","Pub18",""
"INF_SAMOD_2","INF6","Informal competency questions (CQ) SAMOD","CQ = (ID; question; kind of outcome; example answers based on scenario; IDs of higher level informal competency questions)","SAMOD","","",""
"INF_SAMOD_3","INF12, INF38","Glossary of Terms (GoT) SAMOD","","SAMOD","","",""
"INF_SAMOD_4","INF7","Formal competency questions (SQ) SAMOD","Set of queries written in a formal language","SAMOD","","",""
"INF_SAMOD_5","INF58","Modelet SAMOD","A modelet is a stand-alone model describing a particular domain. By definition , a modelet does not include entities from other models and it is not included in other models.  Modelet = (MS; CQ; GoT; TBox; ABox; SQ)","SAMOD","","",""
"INF_SAMOD_6","INF59","Bag of test-cases (BoT) SAMOD","","SAMOD","","",""
"INF_SAMOD_7","INF60","TBox SAMOD","","SAMOD","","",""
"INF_SAMOD_8","INF61","ABox SAMOD","","SAMOD","","",""
"INF_SAMOD_9","INF62","TBox_n SAMOD","The model of the current iteration","SAMOD","","",""
"INF_SAMOD_10","INF63","ABox_n SAMOD","The instance data of the current iteration","SAMOD","","",""
"INF_SAMOD_11","INF64","Modelet_n SAMOD","","SAMOD","","",""